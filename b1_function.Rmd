---
title: "Assignment B1"
author: "Andrew J. Fullerton"
date: "2024-10-31"
output: github_document
---

## Exercise 1/2: Make and document a function
```{r}
library(tidyverse)
```


```{r}
basic_stats <- function(data, x, by, na.rm = TRUE, ...) {
  # Check if input 'data' is a non-empty dataframe or tibble
  if (!is.data.frame(data) || nrow(data) == 0 || ncol(data) == 0) {
    stop("Input data must be a non-empty dataframe or tibble.")
  }

  # Convert to tibble for consistency
  data <- as_tibble(data) 

  # Store variable names
  x_name <- deparse(substitute(x))
  by_name <- deparse(substitute(by))
  
  # Check if 'x' exists and is numeric
  if (!x_name %in% names(data)) {
    stop(x_name, " not found in the data.")
  } 
  
  if (!is.numeric(data |> pull({{x}}))) {
    stop("Variable ", x_name, " must be numeric.")
  }

  # Check if 'by' exists and is usable
  if (!by_name %in% names(data)) {
    stop("Grouping variable ", by_name, " not found in the data.")
  } 
  
  by_var <- data |> pull({{ by }})
  
  if (!is.factor(by_var)) {
    unique_count <- length(unique(by_var))
    if (is.character(by_var) && unique_count < 20 && unique_count > 0) {
      data <- data |> mutate({{ by }} := as.factor({{ by }}))
      warning(by_name, " has been converted to a factor with ", unique_count, " levels.")
    } else {
      stop(by_name, " must be a non-empty factor or a character variable with fewer than 20 unique values.")
    }
  }
  
  # Final check for for 'by' and subgrouping factor levels
  if (length(levels(by_var)) < 2) {
    warning("Grouping variable ", by_name, " only has 1 level.")
  }

  # Run the summary
  result <- data |>
    group_by({{by}}, ...) |>
    summarise(
      mean = mean({{x}}, na.rm = na.rm),
      median = median({{x}}, na.rm = na.rm),
      range = paste0(min({{x}}, na.rm = na.rm), " - ",
                     max({{x}}, na.rm = na.rm)),
      n = n(),
      .groups = "drop"
    )

  return(result)
}

```

## Exercise 3: Include examples

To demonstrate how this function works (and doesn't work), we can use a tried and true dataset: Iris! Iris is a dataframe composed of 5 variables: 4 numeric that measure dimensions of the flowers, and 1 factor variable that specifies the species. We also see that we have 150 rows of data.

```{r}
head(iris)
```

### How it works:

`basic_stats()` takes as input a dataframe or tibble, a numeric variable to compute summary statistics for, and a grouping by variable by which to stratify those summary statistics. Let's see it in action:

```{r}
basic_stats(iris, Sepal.Length, Species)
```

Wow! It's like magic.

To be `base R` friendly and `tidyverse` friendly, `basic_stats()` accepts either a dataframe or a tibble as input data. Here's an example with Iris as a `df`...

```{r}
basic_stats(iris, Sepal.Length, Species)
```

... and here's an example using Iris as a `tibble`. In both cases, the final output is a tibble (courtesy of `dplyr`).

```{r}
iris |> as_tibble() |>
  basic_stats(Sepal.Length, Species)
```

Sometimes when we import a dataset into R, our categorical variables will be classified as `chr` variables. For this reason, the `by` argument can accept either a `fctr` or a `chr`. It should, however, be noted that this function assumes that a `chr` variable with more than 20 unique levels is, in fact, storing text data rather than categorical data; to avoid printing hundred of stratified statistics, the function will throw an error instead of converting the `chr` to a `fctr`. Here's an example with Species as a `fctr`...

```{r}
basic_stats(iris, Sepal.Length, Species)
```

... and here's an example using Species as a `chr` - as you can see, the outputs are identical ...

```{r warning=TRUE}
iris |> mutate(Species = as.character(Species)) |>
  basic_stats(Sepal.Length, Species)
```

... and here's a one more example using Sepal.Width as a `chr` resulting in an error!

```{r error=TRUE}
iris |> mutate(Sepal.Width = as.character(Sepal.Width)) |>
  basic_stats(Sepal.Length, Sepal.Width)
```

Finally, by default, `basic_stats()` removes missing values from the data to enable a clean computation. But, if you like to live dangerously, you can change this by explicitly passing the argument `na.rm = FALSE` into the function. Let's see it in action:

```{r}
library(dplyr)

set.seed(42)

# Create a copy of the iris dataset and introduce NAs in Sepal.Length
iris_with_na <- iris |>
  mutate(Sepal.Length = replace(Sepal.Length, sample(n(), 10), NA))

basic_stats(iris_with_na, Sepal.Length, Species, na.rm = FALSE)
```

Yikes! Let's get back to form...

```{r}
basic_stats(iris_with_na, Sepal.Length, Species)
```

Much better. *And there you have `basic_stats()`!*

## Exercise 4: Test the Function

We've demonstrated what does/doesn't work when using `basic_stats()`, but we should formally test it now!

```{r}
library(testthat)
```


```{r}
# Create test dataset with NAs
set.seed(12)
iris_with_na <- iris |>
  mutate(Sepal.Length = replace(Sepal.Length, sample(n(), 10), NA))

basic_stats(iris, Sepal.Length, Species)

test_that("mean, median, range, and n are computed and output is structured as intended", {
  result <- basic_stats(iris_with_na, Sepal.Length, Species)
  
  expect_s3_class(result, "tbl_df")
  expect_equal(nrow(result), length(levels(iris$Species)))
  expect_true(all(c("mean", "median", "range", "n") %in% names(result)))
  expect_false(any(is.na(result)))
})
```

```{r}
# Create test dataset with type incompatibilities
iris_num_test <- iris |>
  mutate(Sepal.Length = as.factor(Sepal.Length))

iris_chr_test <- iris |>
  mutate(Sepal.Length = as.character(Sepal.Length),
         Species = as.character(Species))

test_that("variable types are handled appropriately", {
  
  expect_error(basic_stats(iris_chr_test, Sepal.Width, Sepal.Length), 
               "Sepal.Length must be a factor or a character variable with fewer than 20 unique values.")
  expect_error(basic_stats(iris_num_test, Sepal.Length, Species),
               "Variable Sepal.Length must be numeric.")
  expect_warning(basic_stats(iris_chr_test, Sepal.Width, Species), 
                 "Species has been converted to a factor with 3 levels.")
})
```








